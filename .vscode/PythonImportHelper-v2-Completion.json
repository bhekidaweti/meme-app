[
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "sqlalchemy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "fileConfig",
        "importPath": "logging.config",
        "description": "logging.config",
        "isExtraImport": true,
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "current_app",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "SQLAlchemy",
        "importPath": "flask_sqlalchemy",
        "description": "flask_sqlalchemy",
        "isExtraImport": true,
        "detail": "flask_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Migrate",
        "importPath": "flask_migrate",
        "description": "flask_migrate",
        "isExtraImport": true,
        "detail": "flask_migrate",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "migrations.versions.7af146f11dbc_initial_migration",
        "description": "migrations.versions.7af146f11dbc_initial_migration",
        "peekOfCode": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('archived_meme',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('meme_url', sa.String(length=255), nullable=False),\n    sa.Column('subreddit', sa.String(length=255), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\ndef downgrade():",
        "detail": "migrations.versions.7af146f11dbc_initial_migration",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "migrations.versions.7af146f11dbc_initial_migration",
        "description": "migrations.versions.7af146f11dbc_initial_migration",
        "peekOfCode": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('archived_meme')\n    # ### end Alembic commands ###",
        "detail": "migrations.versions.7af146f11dbc_initial_migration",
        "documentation": {}
    },
    {
        "label": "revision",
        "kind": 5,
        "importPath": "migrations.versions.7af146f11dbc_initial_migration",
        "description": "migrations.versions.7af146f11dbc_initial_migration",
        "peekOfCode": "revision = '7af146f11dbc'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('archived_meme',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('meme_url', sa.String(length=255), nullable=False),\n    sa.Column('subreddit', sa.String(length=255), nullable=False),",
        "detail": "migrations.versions.7af146f11dbc_initial_migration",
        "documentation": {}
    },
    {
        "label": "down_revision",
        "kind": 5,
        "importPath": "migrations.versions.7af146f11dbc_initial_migration",
        "description": "migrations.versions.7af146f11dbc_initial_migration",
        "peekOfCode": "down_revision = None\nbranch_labels = None\ndepends_on = None\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('archived_meme',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('meme_url', sa.String(length=255), nullable=False),\n    sa.Column('subreddit', sa.String(length=255), nullable=False),\n    sa.PrimaryKeyConstraint('id')",
        "detail": "migrations.versions.7af146f11dbc_initial_migration",
        "documentation": {}
    },
    {
        "label": "branch_labels",
        "kind": 5,
        "importPath": "migrations.versions.7af146f11dbc_initial_migration",
        "description": "migrations.versions.7af146f11dbc_initial_migration",
        "peekOfCode": "branch_labels = None\ndepends_on = None\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('archived_meme',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('meme_url', sa.String(length=255), nullable=False),\n    sa.Column('subreddit', sa.String(length=255), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )",
        "detail": "migrations.versions.7af146f11dbc_initial_migration",
        "documentation": {}
    },
    {
        "label": "depends_on",
        "kind": 5,
        "importPath": "migrations.versions.7af146f11dbc_initial_migration",
        "description": "migrations.versions.7af146f11dbc_initial_migration",
        "peekOfCode": "depends_on = None\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('archived_meme',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('meme_url', sa.String(length=255), nullable=False),\n    sa.Column('subreddit', sa.String(length=255), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###",
        "detail": "migrations.versions.7af146f11dbc_initial_migration",
        "documentation": {}
    },
    {
        "label": "get_engine",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def get_engine():\n    try:\n        # this works with Flask-SQLAlchemy<3 and Alchemical\n        return current_app.extensions['migrate'].db.get_engine()\n    except (TypeError, AttributeError):\n        # this works with Flask-SQLAlchemy>=3\n        return current_app.extensions['migrate'].db.engine\ndef get_engine_url():\n    try:\n        return get_engine().url.render_as_string(hide_password=False).replace(",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "get_engine_url",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def get_engine_url():\n    try:\n        return get_engine().url.render_as_string(hide_password=False).replace(\n            '%', '%%')\n    except AttributeError:\n        return str(get_engine().url).replace('%', '%%')\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "get_metadata",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def get_metadata():\n    if hasattr(target_db, 'metadatas'):\n        return target_db.metadatas[None]\n    return target_db.metadata\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "run_migrations_offline",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "run_migrations_online",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"\n    # this callback is used to prevent an auto-migration from being generated\n    # when there are no changes to the schema\n    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html\n    def process_revision_directives(context, revision, directives):\n        if getattr(config.cmd_opts, 'autogenerate', False):",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "config = context.config\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\nlogger = logging.getLogger('alembic.env')\ndef get_engine():\n    try:\n        # this works with Flask-SQLAlchemy<3 and Alchemical\n        return current_app.extensions['migrate'].db.get_engine()\n    except (TypeError, AttributeError):",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "logger = logging.getLogger('alembic.env')\ndef get_engine():\n    try:\n        # this works with Flask-SQLAlchemy<3 and Alchemical\n        return current_app.extensions['migrate'].db.get_engine()\n    except (TypeError, AttributeError):\n        # this works with Flask-SQLAlchemy>=3\n        return current_app.extensions['migrate'].db.engine\ndef get_engine_url():\n    try:",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "target_db",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "target_db = current_app.extensions['migrate'].db\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\ndef get_metadata():\n    if hasattr(target_db, 'metadatas'):\n        return target_db.metadatas[None]\n    return target_db.metadata\ndef run_migrations_offline():",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "ArchivedMeme",
        "kind": 6,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "class ArchivedMeme(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    meme_url = db.Column(db.String(255), nullable=False)\n    subreddit = db.Column(db.String(255), nullable=False)\n@app.route(\"/\")\ndef index():\n    meme_pic, subreddit = get_meme()\n   # memes_archive.append((meme_pic, subreddit))  # Save the meme to the archive temporaly\n    save_to_database(meme_pic, subreddit)\n    return render_template(\"meme_index.html\", meme_pic=meme_pic, subreddit=subreddit)",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "def index():\n    meme_pic, subreddit = get_meme()\n   # memes_archive.append((meme_pic, subreddit))  # Save the meme to the archive temporaly\n    save_to_database(meme_pic, subreddit)\n    return render_template(\"meme_index.html\", meme_pic=meme_pic, subreddit=subreddit)\n@app.route(\"/archives\")\ndef archives():\n    memes = ArchivedMeme.query.all()\n    return render_template(\"archives.html\", memes=memes)\n@app.route(\"/about\")",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "archives",
        "kind": 2,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "def archives():\n    memes = ArchivedMeme.query.all()\n    return render_template(\"archives.html\", memes=memes)\n@app.route(\"/about\")\ndef about():\n    return render_template(\"about.html\")\ndef get_meme():\n    url = \"https://meme-api.com/gimme\"\n    response = json.loads(requests.request(\"GET\", url).text)\n    meme_large = response[\"preview\"][-2]",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "about",
        "kind": 2,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "def about():\n    return render_template(\"about.html\")\ndef get_meme():\n    url = \"https://meme-api.com/gimme\"\n    response = json.loads(requests.request(\"GET\", url).text)\n    meme_large = response[\"preview\"][-2]\n    subreddit = response[\"subreddit\"]\n    return meme_large, subreddit\ndef save_to_database(meme_pic, subreddit):\n    archived_meme = ArchivedMeme(meme_url=meme_pic, subreddit=subreddit)",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "get_meme",
        "kind": 2,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "def get_meme():\n    url = \"https://meme-api.com/gimme\"\n    response = json.loads(requests.request(\"GET\", url).text)\n    meme_large = response[\"preview\"][-2]\n    subreddit = response[\"subreddit\"]\n    return meme_large, subreddit\ndef save_to_database(meme_pic, subreddit):\n    archived_meme = ArchivedMeme(meme_url=meme_pic, subreddit=subreddit)\n    db.session.add(archived_meme)\n    db.session.commit()",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "save_to_database",
        "kind": 2,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "def save_to_database(meme_pic, subreddit):\n    archived_meme = ArchivedMeme(meme_url=meme_pic, subreddit=subreddit)\n    db.session.add(archived_meme)\n    db.session.commit()\nif __name__ == '__main__':\n    db.create_all()  # Create database tables before running the app\n    app.run(host='0.0.0.0', port=5000)",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "app = Flask('app')\n#memes_archive = []  This code store generated memes temporaly in memory in a list\n##The following code stores generated memes in a SQLIte database\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///memes.db'  # Use SQLite database\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb = SQLAlchemy(app)\nmigrate = Migrate(app, db)\n#class represents the structure of the database table\nclass ArchivedMeme(db.Model):\n    id = db.Column(db.Integer, primary_key=True)",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "#memes_archive",
        "kind": 5,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "#memes_archive = []  This code store generated memes temporaly in memory in a list\n##The following code stores generated memes in a SQLIte database\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///memes.db'  # Use SQLite database\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb = SQLAlchemy(app)\nmigrate = Migrate(app, db)\n#class represents the structure of the database table\nclass ArchivedMeme(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    meme_url = db.Column(db.String(255), nullable=False)",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "app.config['SQLALCHEMY_DATABASE_URI']",
        "kind": 5,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///memes.db'  # Use SQLite database\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb = SQLAlchemy(app)\nmigrate = Migrate(app, db)\n#class represents the structure of the database table\nclass ArchivedMeme(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    meme_url = db.Column(db.String(255), nullable=False)\n    subreddit = db.Column(db.String(255), nullable=False)\n@app.route(\"/\")",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "app.config['SQLALCHEMY_TRACK_MODIFICATIONS']",
        "kind": 5,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb = SQLAlchemy(app)\nmigrate = Migrate(app, db)\n#class represents the structure of the database table\nclass ArchivedMeme(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    meme_url = db.Column(db.String(255), nullable=False)\n    subreddit = db.Column(db.String(255), nullable=False)\n@app.route(\"/\")\ndef index():",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "db = SQLAlchemy(app)\nmigrate = Migrate(app, db)\n#class represents the structure of the database table\nclass ArchivedMeme(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    meme_url = db.Column(db.String(255), nullable=False)\n    subreddit = db.Column(db.String(255), nullable=False)\n@app.route(\"/\")\ndef index():\n    meme_pic, subreddit = get_meme()",
        "detail": "meme",
        "documentation": {}
    },
    {
        "label": "migrate",
        "kind": 5,
        "importPath": "meme",
        "description": "meme",
        "peekOfCode": "migrate = Migrate(app, db)\n#class represents the structure of the database table\nclass ArchivedMeme(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    meme_url = db.Column(db.String(255), nullable=False)\n    subreddit = db.Column(db.String(255), nullable=False)\n@app.route(\"/\")\ndef index():\n    meme_pic, subreddit = get_meme()\n   # memes_archive.append((meme_pic, subreddit))  # Save the meme to the archive temporaly",
        "detail": "meme",
        "documentation": {}
    }
]